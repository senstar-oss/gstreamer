name: Create GStreamer Release

on:
  workflow_call:
    inputs:
      tag_name:
        description: 'Tag name for the release (optional - uses build number if not provided)'
        required: false
        default: ''
        type: string
      release_name:
        description: 'Name for the release (optional - auto-generated if not provided)'
        required: false
        default: ''
        type: string
      target_commitish:
        description: 'Commit SHA to tag (optional - uses current SHA if not provided)'
        required: false
        default: ''
        type: string
      has_linux:
        description: 'Linux build succeeded'
        required: false
        default: false
        type: boolean
      has_windows_mingw:
        description: 'Windows MinGW build succeeded' 
        required: false
        default: false
        type: boolean
      has_windows_msvc:
        description: 'Windows MSVC build succeeded'
        required: false
        default: false
        type: boolean
      has_macos:
        description: 'macOS build succeeded'
        required: false
        default: false
        type: boolean
  
  workflow_dispatch:
    inputs:
      tag_name:
        description: 'Tag name for the release (e.g., test-release-1)'
        required: false
        default: 'test-release'
        type: string
      release_name:
        description: 'Name for the release (e.g., Test Release 1)'
        required: false
        default: 'Test Release'
        type: string
      target_commitish:
        description: 'Commit SHA to tag (leave empty for current)'
        required: false
        default: ''
        type: string
      has_linux:
        description: 'Simulate Linux build succeeded'
        required: false
        default: true
        type: boolean
      has_windows_mingw:
        description: 'Simulate Windows MinGW build succeeded' 
        required: false
        default: true
        type: boolean
      has_windows_msvc:
        description: 'Simulate Windows MSVC build succeeded'
        required: false
        default: true
        type: boolean
      has_macos:
        description: 'Simulate macOS build succeeded'
        required: false
        default: true
        type: boolean

permissions:
  contents: write

jobs:
  create-release:
    runs-on: ubuntu-22.04
    
    steps:
    - name: Create test artifacts (manual dispatch only)
      if: github.event_name == 'workflow_dispatch'
      run: |
        echo "Creating test artifacts for debugging..."
        mkdir -p gstreamer-linux gstreamer-windows-mingw gstreamer-windows-msvc gstreamer-macos
        
        # Create small test files
        ${{ inputs.has_linux && 'echo "Test Linux build" > gstreamer-linux/test-linux.txt && tar -czf gstreamer-test-linux.tar.gz -C gstreamer-linux .' || 'echo "Skipping Linux test artifact"' }}
        ${{ inputs.has_windows_mingw && 'echo "Test MinGW build" > gstreamer-windows-mingw/test-mingw.txt && cd gstreamer-windows-mingw && zip -r ../gstreamer-test-windows-mingw-x64.zip . && cd ..' || 'echo "Skipping MinGW test artifact"' }}
        ${{ inputs.has_windows_msvc && 'echo "Test MSVC build" > gstreamer-windows-msvc/test-msvc.txt && cd gstreamer-windows-msvc && zip -r ../gstreamer-test-windows-msvc-x64.zip . && cd ..' || 'echo "Skipping MSVC test artifact"' }}
        ${{ inputs.has_macos && 'echo "Test macOS build" > gstreamer-macos/test-macos.txt && tar -czf gstreamer-test-macos.tar.gz -C gstreamer-macos .' || 'echo "Skipping macOS test artifact"' }}
        
        echo "Test artifacts created"
        ls -la *.tar.gz *.zip 2>/dev/null || echo "No test artifacts created"
    
    - name: Download all build artifacts
      if: github.event_name == 'workflow_call'
      uses: actions/download-artifact@v4

    - name: List available artifacts
      run: |
        echo "=== Available Build Artifacts ==="
        find . -name "*.tar.gz" -o -name "*.zip" | sort
        
        echo ""
        echo "=== Build Status Summary ==="
        echo "Linux: ${{ inputs.has_linux && '‚úÖ Success' || '‚ùå Failed/Skipped' }}"
        echo "Windows MinGW: ${{ inputs.has_windows_mingw && '‚úÖ Success' || '‚ùå Failed/Skipped' }}"
        echo "Windows MSVC: ${{ inputs.has_windows_msvc && '‚úÖ Success' || '‚ùå Failed/Skipped' }}"
        echo "macOS: ${{ inputs.has_macos && '‚úÖ Success' || '‚ùå Failed/Skipped' }}"

    - name: Generate release notes
      run: |
        cat > release-notes.md << 'EOF'
        # GStreamer Build ${{ github.run_number }}
        
        Automated build of GStreamer with modular workflow architecture.
        
        ## Build Information
        - **Commit**: ${{ github.sha }}
        - **Branch**: ${{ github.ref_name }}
        - **Build Number**: ${{ github.run_number }}
        - **Workflow**: Modular multi-platform build
        
        ## Platform Support
        ${{ inputs.has_linux && '‚úÖ' || '‚ùå' }} **Linux** (Ubuntu 22.04)
        ${{ inputs.has_windows_mingw && '‚úÖ' || '‚ùå' }} **Windows MinGW** (MSYS2/GCC)
        ${{ inputs.has_windows_msvc && '‚úÖ' || '‚ùå' }} **Windows MSVC** (Visual Studio 2022)
        ${{ inputs.has_macos && '‚úÖ' || '‚ùå' }} **macOS** (Homebrew dependencies)
        
        ## Plugin Sets Included
        - **Core GStreamer plugins** - Essential framework components
        - **Base plugins** - Fundamental audio/video processing and playback
        - **Good plugins** - Stable format support, effects, and codecs
        - **Bad plugins** - Experimental features, WebRTC, OpenCV, advanced codecs
        - **Ugly plugins** - Patent-encumbered codecs (MP3, H.264, DVD, etc.)
        - **LibAV plugins** - FFmpeg integration for extensive codec support
        - **GES** (GStreamer Editing Services) - Non-linear video editing
        - **RTSP Server** - Real Time Streaming Protocol server
        - **Development tools** - gst-inspect, gst-launch, debugging tools
        
        ## Key Features
        - ‚úÖ **GPL plugins enabled** - Includes patent-encumbered codecs
        - ‚úÖ **WebRTC support** - Real-time communication capabilities
        - ‚úÖ **Hardware acceleration** - VA-API, VDPAU, platform-specific optimizations
        - ‚úÖ **ORC optimizations** - SIMD performance improvements
        - ‚úÖ **Introspection data** - Complete API bindings support (Linux/macOS)
        
        ## Usage Instructions
        
        ### Linux/macOS
        ```bash
        # Extract the tarball
        tar -xzf gstreamer-*-linux.tar.gz  # or gstreamer-*-macos.tar.gz
        
        # Set environment variables
        export GST_PLUGIN_PATH=$PWD/usr/lib/gstreamer-1.0
        export LD_LIBRARY_PATH=$PWD/usr/lib  
        export PATH=$PWD/usr/bin:$PATH
        
        # Test installation
        gst-inspect-1.0 --version
        gst-launch-1.0 videotestsrc ! autovideosink
        ```
        
        ### Windows
        ```powershell
        # Extract the zip file
        # Add bin directory to PATH
        $env:PATH = "path\to\extracted\bin;$env:PATH"
        
        # Test installation
        gst-inspect-1.0.exe --version
        gst-launch-1.0.exe videotestsrc ! autovideosink
        ```
        
        ## Artifacts Description
        ${{ inputs.has_linux && '- `gstreamer-*-linux.tar.gz` - Complete Linux build with full plugin set' || '' }}
        ${{ inputs.has_windows_mingw && '- `gstreamer-*-windows-mingw-*.zip` - Windows build using MinGW/GCC toolchain' || '' }}
        ${{ inputs.has_windows_msvc && '- `gstreamer-*-windows-msvc-*.zip` - Windows build using Visual Studio/MSVC' || '' }}
        ${{ inputs.has_macos && '- `gstreamer-*-macos.tar.gz` - macOS build with Homebrew dependencies' || '' }}
        
        ## Build Architecture
        This release uses a modular workflow architecture:
        - **Dispatcher workflow** - Orchestrates parallel builds based on user inputs
        - **Platform-specific workflows** - Dedicated build workflows for each platform
        - **Plugin verification** - Automated testing of built plugins
        - **Conditional building** - Build only selected platforms and plugin sets
        
        ---
        
        **Note**: This is an automated build. For stable releases, please use official GStreamer releases from https://gstreamer.freedesktop.org/
        EOF

    - name: Prepare release files
      run: |
        # Create a directory for release files
        mkdir -p release-files
        
        # Copy artifacts to release directory with consistent naming
        ${{ inputs.has_linux && 'find . -name "gstreamer-*-linux.tar.gz" -exec cp {} release-files/ \;' || 'echo "No Linux artifacts to copy"' }}
        ${{ inputs.has_windows_mingw && 'find . -name "gstreamer-*-windows-mingw-*.zip" -exec cp {} release-files/ \;' || 'echo "No MinGW artifacts to copy"' }}  
        ${{ inputs.has_windows_msvc && 'find . -name "gstreamer-*-windows-msvc-*.zip" -exec cp {} release-files/ \;' || 'echo "No MSVC artifacts to copy"' }}
        ${{ inputs.has_macos && 'find . -name "gstreamer-*-macos.tar.gz" -exec cp {} release-files/ \;' || 'echo "No macOS artifacts to copy"' }}
        
        echo "=== Release Files ==="
        ls -la release-files/

    - name: Create or Update GitHub Release
      id: create_release
      uses: actions/github-script@v7
      env:
        TAG_NAME: ${{ inputs.tag_name != '' && inputs.tag_name || format('build-{0}', github.run_number) }}
        RELEASE_NAME: ${{ inputs.release_name != '' && inputs.release_name || format('GStreamer Build {0}', github.run_number) }}
        TARGET_COMMIT: ${{ inputs.target_commitish != '' && inputs.target_commitish || github.sha }}
        IS_PRERELEASE: ${{ inputs.tag_name == '' }}
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const fs = require('fs');
          const tagName = process.env.TAG_NAME;
          const releaseName = process.env.RELEASE_NAME;
          const targetCommit = process.env.TARGET_COMMIT;
          const isPrerelease = process.env.IS_PRERELEASE === 'true';
          
          // Read release notes
          let releaseNotes = '';
          if (fs.existsSync('release-notes.md')) {
            releaseNotes = fs.readFileSync('release-notes.md', 'utf8');
          } else {
            core.warning('Release notes file not found');
            releaseNotes = `Release ${tagName}`;
          }
          
          // Check if release already exists
          let release;
          try {
            const existingRelease = await github.rest.repos.getReleaseByTag({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag: tagName
            });
            release = existingRelease.data;
            core.info(`Release already exists: ${release.html_url}`);
            
            // Update existing release body (append)
            await github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: release.id,
              body: release.body + '\n\n---\n\n' + releaseNotes
            });
            core.info('Updated existing release with new build information');
          } catch (error) {
            if (error.status === 404) {
              // Create new release
              core.info(`Creating new release for tag: ${tagName}`);
              const newRelease = await github.rest.repos.createRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag_name: tagName,
                name: releaseName,
                body: releaseNotes,
                draft: false,
                prerelease: isPrerelease,
                target_commitish: targetCommit
              });
              release = newRelease.data;
              core.info(`Created release: ${release.html_url}`);
            } else {
              throw error;
            }
          }
          
          core.setOutput('release_id', release.id);
          core.setOutput('release_url', release.html_url);

    - name: Upload Release Assets
      uses: actions/github-script@v7
      env:
        RELEASE_ID: ${{ steps.create_release.outputs.release_id }}
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const fs = require('fs');
          const path = require('path');
          const releaseId = process.env.RELEASE_ID;
          const artifactsDir = 'release-files';
          
          // Check if directory exists
          if (!fs.existsSync(artifactsDir)) {
            core.warning(`Artifacts directory not found: ${artifactsDir}`);
            return;
          }
          
          // Get all files in artifacts directory
          const files = fs.readdirSync(artifactsDir);
          if (files.length === 0) {
            core.warning(`No files found in ${artifactsDir}`);
            return;
          }
          
          core.info(`Found ${files.length} file(s) to upload`);
          
          // Get existing assets to avoid duplicates
          const existingAssets = await github.rest.repos.listReleaseAssets({
            owner: context.repo.owner,
            repo: context.repo.repo,
            release_id: releaseId
          });
          
          for (const file of files) {
            const filePath = path.join(artifactsDir, file);
            const stats = fs.statSync(filePath);
            
            if (!stats.isFile()) {
              core.info(`Skipping non-file: ${file}`);
              continue;
            }
            
            const fileSizeMB = (stats.size / 1024 / 1024).toFixed(2);
            core.info(`Processing: ${file} (${fileSizeMB} MB)`);
            
            // Check if asset already exists
            const existingAsset = existingAssets.data.find(a => a.name === file);
            if (existingAsset) {
              core.info(`Asset ${file} already exists, deleting old version...`);
              await github.rest.repos.deleteReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                asset_id: existingAsset.id
              });
            }
            
            // Upload new asset
            const fileContent = fs.readFileSync(filePath);
            core.info(`Uploading ${file}...`);
            
            await github.rest.repos.uploadReleaseAsset({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId,
              name: file,
              data: fileContent
            });
            
            core.info(`‚úÖ Uploaded: ${file}`);
          }
          
          core.info('All assets uploaded successfully!');

    - name: Release summary
      env:
        TAG_NAME: ${{ inputs.tag_name != '' && inputs.tag_name || format('build-{0}', github.run_number) }}
        RELEASE_URL: ${{ steps.create_release.outputs.release_url }}
      run: |
        echo "=== Release Created Successfully ==="
        echo "Tag: ${TAG_NAME}"
        echo "Release URL: ${RELEASE_URL}"
        
        # Count successful builds
        SUCCESS_COUNT=0
        ${{ inputs.has_linux && 'SUCCESS_COUNT=$((SUCCESS_COUNT + 1))' || '' }}
        ${{ inputs.has_windows_mingw && 'SUCCESS_COUNT=$((SUCCESS_COUNT + 1))' || '' }}
        ${{ inputs.has_windows_msvc && 'SUCCESS_COUNT=$((SUCCESS_COUNT + 1))' || '' }}
        ${{ inputs.has_macos && 'SUCCESS_COUNT=$((SUCCESS_COUNT + 1))' || '' }}
        
        echo "Successful builds: $SUCCESS_COUNT/4 platforms"
        
        if [ $SUCCESS_COUNT -eq 0 ]; then
          echo "‚ö†Ô∏è No builds succeeded - empty release created"
        elif [ $SUCCESS_COUNT -eq 4 ]; then
          echo "üéâ All platform builds succeeded!"
        else
          echo "‚úÖ Partial success - some platform builds completed"
        fi